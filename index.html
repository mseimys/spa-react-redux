<!doctype html>
<html lang="en">

<head>
<meta charset="utf-8">

<title>Modern Architecture of Single Page Applications: React+Redux Case Study</title>

<meta name="description" content="">
<meta name="author" content="">

<meta name="apple-mobile-web-app-capable" content="yes" />
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />

<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, minimal-ui">

<link rel="stylesheet" href="css/reveal.css">
<link rel="stylesheet" href="css/theme/serif.css" id="theme">

<!-- Code syntax highlighting -->
<link rel="stylesheet" href="lib/css/highlightjs/obsidian.css">

<!-- Printing and PDF exports -->
<script>
	var link = document.createElement( 'link' );
	link.rel = 'stylesheet';
	link.type = 'text/css';
	link.href = window.location.search.match( /print-pdf/gi ) ? 'css/print/pdf.css' : 'css/print/paper.css';
	document.getElementsByTagName( 'head' )[0].appendChild( link );
</script>

<style>
.reveal section img {
	border: 0;
}
</style>

<!--[if lt IE 9]>
<script src="lib/js/html5shiv.js"></script>
<![endif]-->
</head>

<body>

<div class="reveal">
	<div class="slides">
		<section>
			<h3>Modern Architecture of SPA: React+Redux Case Study</h3>
			<h4>Matas Šeimys</h4>
			<img style="padding: 10px; width: 200px" src="imgs/adform.png"/>
			<p><small>2016 08 25</small></p>
		</section>

		<section>
			<img class="stretch"  src="imgs/js_framework_switching.png"/>
		</section>

		<section>
			<img class="stretch" src="imgs/web-history.png" />
		</section>

		<section>
			<h2>About me</h2>
			<p>(Mostly frontend) Developer at Adform</p>
			<p>Buyer Unit, Buying Workflow POD</p>
			<p>Latest frontend stack in use: React+Redux+Immutable.js+TypeScript+Webpack</p>
		</section>

		<section data-markdown>
## Overview

* What is a single page application
* Functional reactive programming
* React
* Redux
* React + Redux = ♡
		</section>

		<section data-markdown>
## Web applications of the past
		</section>
		<section>
			<img class="stretch"  src="imgs/old.jpg"/>
			<!-- source: http://satish-tech-talks.blogspot.lt/2012/12/architecture-of-modern-web-application.html -->
		</section>
		<section data-markdown>
			## Pros
* Fast / Light
* Indexable
* Cacheble

			## Cons
* Poor UI/UX
* Generic views
* Hard to update
		</section>

		<section data-markdown>
			## Not static, but not SPA yet
* AJAX calls... page is updated here and there
* Impossible to index
* Business logic implemented twice
* HTML can be: on server, generated by JS, inline strings
		</section>

		<section data-markdown>
			Introducing...
			## Single Page Applications
		</section>

		<section>
			<img class="stretch"  src="imgs/new.jpg"/>
			<!-- source: http://satish-tech-talks.blogspot.lt/2012/12/architecture-of-modern-web-application.html -->
		</section>

		<section data-markdown>
			## Benefits of SPA

			* Better user experience
			* Independent backend
			* Minimum at backend
			* Independent frontend
		</section>

		<section>
			<h2>Example of a complex SPA</h2>
		</section>

		<section data-background="imgs/google-contacts.png">
		</section>

		<section>
			<h3>First attempt building such app</h3>
			<img src="imgs/spaghetti.png"/>
		</section>

		<section data-markdown>
			## Let's refactor...

* Split model into parts
* Add some message bus
* Add some "cool new" library
		</section>

		<section>
			<h3>End result after a few years</h3>
			<img src="imgs/complexity.png"/>
		</section>

		<section>
			<h2>Functional Reactive Programming</h2>
			<!-- What is it? The simple answer to this question is that there is no simple answer. -->
			<p>Programming paradigm, introduced in 1997</p>
			<p>FRP is about datatypes that represent a value '<b>over time</b>'</p>
			<p>You can define these values and combine them, pass them into & out of functions</p>
			<p data-markdown>`.filter(...).map(...).reduce(...)`</p>
		</section>
		<section>
			<h2>Value 'over time'?</h2>

<pre><code class="javascript" data-trim>
var x = {{mouse-x}};  // value 'over time': 10, 20, 30, 15...
var y = {{mouse-y}};

minX = x - 16;
minY = y - 16;
maxX = x + 16;
maxY = y + 16;  // new values out of values 'over time'

rectangle(minX, minY, maxX, maxY)  // draws rectangle 'over time'
</code></pre>
		</section>

		<section data-markdown>
			### Functional Reactive Programming
			## Core concepts

1. One-way state transitions
2. Immutable data
3. Pure functions
4. Observables
5. Static typing

These are not new stuff, just collected together
		</section>

		<section>
			<h2>1. One-way state transitions</h2>
			<p>Most significant of FRP: Changes to the model all go through a common type of dispatcher</p>
			<img src="imgs/one-way.png" />
		</section>

		<section>
			<h2>2. Immutable data</h2>
<p>Immutable object is an object whose state cannot be modified after it is created</p>
<pre><code class="javascript" data-trim>
var x = { a: 1, b: 2 };
var y = x;
x.a = 3;  // mutation!
x === y   // true
</code></pre>

<pre><code class="javascript" data-trim>
var x = { a: 1, b: 2 };
var y = Object.assign({}, x);  // clone
x2 = x.set("a", 3);  // x stays the same
x === y              // false
x === x2             // false
</code></pre>

		</section>
		<section>
			<h2>Why immutable data?</h2>
			<img src="imgs/observable-tree.png"/>
			<p>Amazing change detection perfomance!</p>
		</section>

		<section>
			<h2>3. Pure functions</h2>
			<p><b>No side effects</b>: simple to build, test, and maintain</p>
			<p>Follow the <b>single responsibility principle</b> and keeps things simple</p>
		</section>

		<section>
			<h2>Example of Non Pure</h2>
			<pre><code class="javascript" data-trim>
var thing = createObjectWithCurrentDate();
var n = generateRandom();

var total = 0;

function pickItem(customer, item) {
  if (!authService.isLoggedIn()) return;  // or throw, or redirect

  if (customer.hasNoBasket) {
    customer.basket = [];
  }
  customer.basket.push(item.id);
  total++;
}
			</code></pre>
		</section>

		<section data-markdown>
			## Last two concepts of FRP
* `4.` Observables - exist in JS already, but in far more robust sense, RxJS anyone?
* `5.` Static typing - avoiding runtime errors, TypeScript?
		</section>

		<section data-markdown>
			## React & Redux
* Their combo uses most of these principles
		</section>

		<section data-markdown>
			## Let's React!
* High perfomance Virtual DOM implementation
* All about the view
* One-way data flow
* Everything is a component
		</section>

		<section>
			<h2>React Components</h2>
			<p><b>Single responsibility principle:</b></p>
			<p>A component should ideally only do one thing</p>
			<img src="imgs/components.png"/>
		</section>

		<section>
			<h2>Simple React App</h2>
		<pre><code class="javascript" data-trim>
import * as React from "react";
import * as ReactDOM from "react-dom";

class Hello extends React.Component {
    render() {
        return <div>Hello {this.props.name}!</div>;
    }
}

ReactDOM.render(
    &lt;Hello name="React" />,
    document.getElementById("app")
);
</code></pre>
		</section>

		<section>
			<h2>Component with State</h2>
		<pre><code class="javascript" data-trim>
export class Hello extends React.Component {
    constructor() {
        super();
        this.state = { counter: 0 };
    }
    handleClick() {
        this.setState({counter: this.state.counter + 1});
    }
    render() {
        return <div>
            <div>{this.props.name} counter: {this.state.counter}!</div> <br/>
            <button onClick={() => this.handleClick()}>INC</button>
        </div>;
    }
}

&lt;Hello name="React" />,
</code></pre>
		</section>

		<section data-markdown>
			## Component Lifecycle
Virtual DOM in action! :)

* `componentDidMount` - called once, after initial rendering
* `shouldComponentUpdate` - if `true` - call `render()`
* `componentDidUpdate` - called after updates are flushed to the DOM
* ...
		</section>

		<section>
			<h2>Pure Components</h2>
		<pre><code class="javascript" data-trim>
class Hello extends React.PureComponent { ... }

const Hey = ({ name }) => <div>Hey {name}!</div>;

// or with named function
function Hey({ name }) {
    return <div>Hey {name}!</div>;
}
</code></pre>
		</section>

		<section>
			<h2>More components!</h2>
		<pre><code class="javascript" data-trim>
import {UserList} from './components/user-list';
import {Header} from './components/header';
import {InfoBox} from './components/helpers';

class App extends React.Component {
    render() {
        return
            <div>
                &lt;Header onClick={...}>&ltInfoBox message={...}/>&lt;/Header>
                &lt;UserList users={this.state.users}/>
            </div>;
    }
}

ReactDOM.render(&lt;App />, document.getElementById("app"));
</code></pre>
		</section>

		<section>
			<h2>Communication</h2>
			<img src="imgs/poor-communicate.svg"/>
			<!-- Source: https://css-tricks.com/learning-react-redux/ -->
			<p>Leads to spaghetti code!</p>
		</section>

		<section>
			<img width="300px" src="imgs/logo-redux.png"/>
			<p>Redux is a tool for managing both data-state and UI-state in JavaScript applications. Can be any framework!</p>
		</section>

		<section>
			<img class="stretch" src="imgs/react-redux.png"/>
		</section>

		<section data-markdown>
			## Redux principles
* Everything starts with an action
* Single source of truth - store
* State is read-only
* Changes to state are made with pure functions (*reducers*)
		</section>

		<section>
			<h2>State Changes</h2>
			<img src="imgs/one-reducer.svg"/>
			<!-- Source: https://css-tricks.com/learning-react-redux/ -->
		</section>

		<section>
			<h2>Sample reducer</h2>
		<pre><code class="javascript" data-trim>
const initialState = 1;
const INCREMENT = "INCREMENT";

// Incomming action: { type: INCREMENT, amount: 10 }
// Look Ma, pure function!
function myReducer(state = initialState, action) {
  switch (action.type) {
    case INCREMENT:
      return state + action.amount;
    default:
      return state;
    }
}
</code></pre>
		</section>

		<section>
			<h2>Proper reducer with mutable objects</h2>
		<pre><code class="javascript" data-trim>
const initialState = [];

// action: { type: ADD_USER, user: "Matas" }
function reducer(state = initialState, action) {
  switch (action.type) {
    case ADD_USER:
      return state.concat([action.user]); // creates new state
    default:
      return state;
    }
}
</code></pre>
		</section>

		<section>
			<h2>Combining reducers</h2>
		<pre><code class="javascript" data-trim>
import { createStore, combineReducers } from "redux";

// The User Reducer
const userReducer = function(state = {}, action) {
  return state;
}
// The Widget Reducer
const widgetReducer = function(state = {}, action) {
  return state;
}
// Combine Reducers
const reducers = combineReducers({
  userState: userReducer,
  widgetState: widgetReducer
});

const store = createStore(reducers);
		</code></pre>
		</section>

		<section>
			<img src="imgs/reducer.svg"/>
			<!-- Source: https://css-tricks.com/learning-react-redux/ -->
		</section>

		<section>
			<h2>Connect everything!<span style="font-size: 14px">said PD</span></h2>
			<img class="stretch" src="imgs/redux.svg"/>
			<!-- Source: https://css-tricks.com/learning-react-redux/ -->
		</section>

		<section>
			<h2>Here be values 'over time'!!</h2>
		<pre><code class="javascript" data-trim>
import {connect} from "react-redux";

const mapStateToProps = (state) => ({
    counter: state.counter
});
const mapDispatchToProps = (dispatch) => ({
    onIncrement: (amount) => { dispatch(increment(amount)) }
});

// Connect to state value 'over time'
export const ConnectedMyComponent = connect(
    mapStateToProps,
    mapDispatchToProps
)(MyComponent);

// Behind the scenes MyComponent recieves new props:
// &lt;ConnectedMyComponent counter={...} onIncrement={...}/>
		</code></pre>
		</section>

		<section data-markdown>
			## Wrapping it up
* Functional Reactive Programming principles
* **Redux** with single store for application state
* **React** for fast state reflection into DOM
		</section>

		<section>
			<h2>Final words</h2>
			<ul>
				<li>No "best JS framework" that fits it all</li>
				<li>Understand paradigms, principles and patterns</li>
				<li>Try to grasp the reasons behind each new framework</li>
			</ul>
		</section>

		<section>
			<img class="stretch" src="imgs/software-engineer.jpg" />
		</section>

		<section>
			<!-- Most common question in forums “What should I learn now?” Or “What should I learn first?”. -->
			<h2>Do not be like the dog :)</h2>
			<img src="imgs/dog.jpg" />
			<p>You should aim to understand the root.</p><p>Less distraction, more focus.</p>
		</section>

		<section data-markdown>
			## Code

You can play with React+Redux here:

https://github.com/mseimys/minimal-react-redux

(Minimal amount of boilerplate code)
		</section>

		<section data-markdown>
			## Sources

* https://css-tricks.com/learning-react-redux/
* http://satish-tech-talks.blogspot.lt/2012/12/architecture-of-modern-web-application.html
* http://www.slideshare.net/scothis/aoa-mwa
* http://blog.bitovi.com/longevity-or-lack-thereof-in-javascript-frameworks/
		</section>

	</div>
</div>

<script src="lib/js/head.min.js"></script>
<script src="js/reveal.js"></script>

<script>

	// Full list of configuration options available at:
	// https://github.com/hakimel/reveal.js#configuration
	Reveal.initialize({
		controls: false,
		progress: true,
		history: true,
		center: true,

		transition: 'none', // none/fade/slide/convex/concave/zoom

		// Optional reveal.js plugins
		dependencies: [
			{ src: 'lib/js/classList.js', condition: function() { return !document.body.classList; } },
			{ src: 'plugin/markdown/marked.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
			{ src: 'plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
			{ src: 'plugin/highlight/highlight.pack.js', async: true, condition: function() { return !!document.querySelector( 'pre code' ); }, callback: function() { hljs.initHighlightingOnLoad(); } },
			{ src: 'plugin/zoom-js/zoom.js', async: true },
			{ src: 'plugin/notes/notes.js', async: true }
		]
	});

</script>

</body>
</html>
